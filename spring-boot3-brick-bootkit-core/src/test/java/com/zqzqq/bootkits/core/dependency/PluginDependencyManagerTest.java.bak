package com.zqzqq.bootkits.core.dependency;

import com.zqzqq.bootkits.core.plugin.Plugin;
import com.zqzqq.bootkits.core.plugin.PluginManager;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.*;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

/**
 * 插件依赖管理器测试
 */
@DisplayName("PluginDependencyManager Test")
class PluginDependencyManagerTest {

    @Mock
    private PluginManager mockPluginManager;

    @Mock
    private Plugin mockPlugin;

    private PluginDependencyManager dependencyManager;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        dependencyManager = new PluginDependencyManager(mockPluginManager);
    }

    @Test
    @DisplayName("测试依赖管理器初始化")
    void testDependencyManagerInitialization() {
        assertThat(dependencyManager).isNotNull();
        
        // 验证初始状态
        assertThat(dependencyManager.getRegisteredPluginCount()).isEqualTo(0);
    }

    @Test
    @DisplayName("测试注册插件依赖")
    void testRegisterPluginDependency() {
        PluginDependency dependency = PluginDependency.newBuilder("test-plugin")
            .setType(PluginDependencyType.REQUIRED)
            .addVersionConstraint("dep1", VersionConstraint.parse(">=1.0.0"))
            .build();

        dependencyManager.registerPluginDependency("test-plugin", dependency);

        assertThat(dependencyManager.getRegisteredPluginCount()).isEqualTo(1);
        assertThat(dependencyManager.getPluginDependencies("test-plugin")).containsExactly("test-plugin");
    }

    @Test
    @DisplayName("测试重复注册依赖")
    void testDuplicateDependencyRegistration() {
        PluginDependency dependency1 = PluginDependency.newBuilder("test-plugin")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        PluginDependency dependency2 = PluginDependency.newBuilder("test-plugin")
            .setType(PluginDependencyType.OPTIONAL)
            .build();

        dependencyManager.registerPluginDependency("test-plugin", dependency1);
        dependencyManager.registerPluginDependency("test-plugin", dependency2);

        // 第二次注册应该覆盖第一次
        assertThat(dependencyManager.getRegisteredPluginCount()).isEqualTo(1);
    }

    @Test
    @DisplayName("测试解析依赖")
    void testResolveDependencies() {
        PluginDependency dependency = PluginDependency.newBuilder("plugin-a")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        dependencyManager.registerPluginDependency("plugin-a", dependency);

        PluginDependencyResolution resolution = dependencyManager.resolveDependencies("plugin-a");
        
        assertThat(resolution).isNotNull();
        assertThat(resolution.isSuccess()).isTrue();
        assertThat(resolution.getResolvedDependencies()).contains("plugin-a");
    }

    @Test
    @DisplayName("测试解析不存在的插件依赖")
    void testResolveNonExistentPlugin() {
        PluginDependencyResolution resolution = dependencyManager.resolveDependencies("non-existent-plugin");
        
        assertThat(resolution).isNotNull();
        assertThat(resolution.isSuccess()).isFalse();
        assertThat(resolution.getErrors()).isNotEmpty();
    }

    @Test
    @DisplayName("测试检查插件兼容性")
    void testCheckCompatibility() {
        PluginDependency dependency = PluginDependency.newBuilder("plugin-a")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        dependencyManager.registerPluginDependency("plugin-a", dependency);

        Collection<String> existingPlugins = Arrays.asList("plugin-a");
        PluginCompatibilityResult result = dependencyManager.checkCompatibility("plugin-a", existingPlugins);

        assertThat(result).isNotNull();
        assertThat(result.isCompatible()).isTrue();
        assertThat(result.getErrors()).isEmpty();
    }

    @Test
    @DisplayName("测试检查兼容性 - 版本冲突")
    void testCheckCompatibilityWithVersionConflict() {
        PluginDependency dependency = PluginDependency.newBuilder("plugin-a")
            .setType(PluginDependencyType.REQUIRED)
            .addVersionConstraint("conflict-plugin", VersionConstraint.parse(">=2.0.0"))
            .build();

        dependencyManager.registerPluginDependency("plugin-a", dependency);

        Collection<String> existingPlugins = Arrays.asList("conflict-plugin");
        PluginCompatibilityResult result = dependencyManager.checkCompatibility("plugin-a", existingPlugins);

        // 由于我们无法模拟具体的版本信息，这个测试主要验证方法调用不会异常
        assertThat(result).isNotNull();
    }

    @Test
    @DisplayName("测试获取插件依赖")
    void testGetPluginDependencies() {
        PluginDependency dependency1 = PluginDependency.newBuilder("plugin-a")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        PluginDependency dependency2 = PluginDependency.newBuilder("plugin-b")
            .setType(PluginDependencyType.OPTIONAL)
            .build();

        dependencyManager.registerPluginDependency("plugin-a", dependency1);
        dependencyManager.registerPluginDependency("plugin-b", dependency2);

        assertThat(dependencyManager.getPluginDependencies("plugin-a")).containsExactly("plugin-a");
        assertThat(dependencyManager.getPluginDependencies("plugin-b")).containsExactly("plugin-b");
        assertThat(dependencyManager.getPluginDependencies("non-existent")).isEmpty();
    }

    @Test
    @DisplayName("测试获取反向依赖")
    void testGetReverseDependencies() {
        PluginDependency dependency1 = PluginDependency.newBuilder("plugin-a")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        PluginDependency dependency2 = PluginDependency.newBuilder("plugin-b")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        dependencyManager.registerPluginDependency("plugin-a", dependency1);
        dependencyManager.registerPluginDependency("plugin-b", dependency2);

        // plugin-a 和 plugin-b 都依赖自己，所以reverse依赖应该包含自己
        assertThat(dependencyManager.getReverseDependencies("plugin-a")).containsExactly("plugin-a");
        assertThat(dependencyManager.getReverseDependencies("plugin-b")).containsExactly("plugin-b");
    }

    @Test
    @DisplayName("测试依赖循环检测")
    void testDependencyCycleDetection() {
        PluginDependency dependency1 = PluginDependency.newBuilder("plugin-a")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        PluginDependency dependency2 = PluginDependency.newBuilder("plugin-b")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        dependencyManager.registerPluginDependency("plugin-a", dependency1);
        dependencyManager.registerPluginDependency("plugin-b", dependency2);

        // 由于没有实际循环依赖，应该返回false
        assertThat(dependencyManager.hasDependencyCycle("plugin-a")).isFalse();
        assertThat(dependencyManager.hasDependencyCycle("plugin-b")).isFalse();
    }

    @Test
    @DisplayName("测试拓扑排序")
    void testTopologicalOrder() {
        List<String> order = dependencyManager.getTopologicalOrder();
        
        // 初始状态下应该返回空列表或只包含已注册的插件
        assertThat(order).isNotNull();
    }

    @Test
    @DisplayName("测试已注册插件数量")
    void testRegisteredPluginCount() {
        assertThat(dependencyManager.getRegisteredPluginCount()).isEqualTo(0);

        PluginDependency dependency = PluginDependency.newBuilder("test-plugin")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        dependencyManager.registerPluginDependency("test-plugin", dependency);
        assertThat(dependencyManager.getRegisteredPluginCount()).isEqualTo(1);

        dependencyManager.registerPluginDependency("test-plugin", dependency); // 重复注册
        assertThat(dependencyManager.getRegisteredPluginCount()).isEqualTo(1);
    }

    @Test
    @DisplayName("测试构造函数参数验证")
    void testConstructorParameterValidation() {
        assertThatThrownBy(() -> new PluginDependencyManager(null))
            .isInstanceOf(IllegalArgumentException.class);
    }

    @Test
    @DisplayName("测试复杂依赖场景")
    void testComplexDependencyScenario() {
        // 注册多个插件及其依赖
        PluginDependency depA = PluginDependency.newBuilder("plugin-a")
            .setType(PluginDependencyType.REQUIRED)
            .addVersionConstraint("core", VersionConstraint.parse(">=2.0.0"))
            .build();

        PluginDependency depB = PluginDependency.newBuilder("plugin-b")
            .setType(PluginDependencyType.OPTIONAL)
            .addVersionConstraint("plugin-a", VersionConstraint.parse(">=1.0.0"))
            .build();

        PluginDependency depC = PluginDependency.newBuilder("plugin-c")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        dependencyManager.registerPluginDependency("plugin-a", depA);
        dependencyManager.registerPluginDependency("plugin-b", depB);
        dependencyManager.registerPluginDependency("plugin-c", depC);

        assertThat(dependencyManager.getRegisteredPluginCount()).isEqualTo(3);

        // 测试解析依赖
        PluginDependencyResolution resolution = dependencyManager.resolveDependencies("plugin-a");
        assertThat(resolution.isSuccess()).isTrue();

        // 测试兼容性检查
        PluginCompatibilityResult compatibility = dependencyManager.checkCompatibility("plugin-a", Arrays.asList("plugin-b", "plugin-c"));
        assertThat(compatibility).isNotNull();
    }

    @Test
    @DisplayName("测试空操作处理")
    void testEmptyOperationsHandling() {
        // 测试解析空插件
        PluginDependencyResolution resolution = dependencyManager.resolveDependencies("");
        assertThat(resolution).isNotNull();
        assertThat(resolution.isSuccess()).isFalse();

        // 测试检查空插件兼容性
        PluginCompatibilityResult compatibility = dependencyManager.checkCompatibility("", Arrays.asList("plugin-a"));
        assertThat(compatibility).isNotNull();

        // 测试获取空插件依赖
        assertThat(dependencyManager.getPluginDependencies("")).isEmpty();
        assertThat(dependencyManager.getReverseDependencies("")).isEmpty();
        assertThat(dependencyManager.hasDependencyCycle("")).isFalse();
    }

    @Test
    @DisplayName("测试并发操作安全性")
    void testConcurrentOperationSafety() throws InterruptedException {
        PluginDependency dependency = PluginDependency.newBuilder("concurrent-plugin")
            .setType(PluginDependencyType.REQUIRED)
            .build();

        int threadCount = 10;
        Thread[] threads = new Thread[threadCount];

        for (int i = 0; i < threadCount; i++) {
            threads[i] = new Thread(() -> {
                dependencyManager.registerPluginDependency("concurrent-plugin", dependency);
            });
            threads[i].start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        // 验证最终状态一致
        assertThat(dependencyManager.getRegisteredPluginCount()).isEqualTo(1);
        assertThat(dependencyManager.getPluginDependencies("concurrent-plugin")).containsExactly("concurrent-plugin");
    }

    @Test
    @DisplayName("测试依赖管理器的线程安全性")
    void testThreadSafety() throws InterruptedException {
        int operationCount = 100;
        Thread[] threads = new Thread[10];

        for (int i = 0; i < threads.length; i++) {
            final int threadIndex = i;
            threads[i] = new Thread(() -> {
                for (int j = 0; j < operationCount / threads.length; j++) {
                    String pluginId = "plugin-" + threadIndex + "-" + j;
                    PluginDependency dependency = PluginDependency.newBuilder(pluginId)
                        .setType(PluginDependencyType.REQUIRED)
                        .build();

                    dependencyManager.registerPluginDependency(pluginId, dependency);
                    
                    // 执行一些读取操作
                    dependencyManager.getRegisteredPluginCount();
                    dependencyManager.resolveDependencies(pluginId);
                }
            });
            threads[i].start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        // 验证没有发生死锁或异常，所有操作都成功完成
        assertThat(dependencyManager.getRegisteredPluginCount()).isGreaterThan(0);
    }
}