package com.zqzqq.bootkits.core.health;

import com.zqzqq.bootkits.core.plugin.Plugin;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

/**
 * 插件健康检查器接口测试
 */
@DisplayName("PluginHealthChecker Test")
class PluginHealthCheckerTest {

    @Mock
    private Plugin mockPlugin;

    @Mock
    private PluginHealthChecker mockChecker;

    @DisplayName("设置测试环境")
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    @DisplayName("测试检查器名称和描述")
    void testCheckerNameAndDescription() {
        String name = "test-checker";
        String description = "Test health checker";

        // 模拟检查器方法
        when(mockChecker.getName()).thenReturn(name);
        when(mockChecker.getDescription()).thenReturn(description);

        assertThat(mockChecker.getName()).isEqualTo(name);
        assertThat(mockChecker.getDescription()).isEqualTo(description);
    }

    @Test
    @DisplayName("测试检查器启用状态")
    void testCheckerEnabledState() {
        when(mockChecker.isEnabled()).thenReturn(true);
        assertThat(mockChecker.isEnabled()).isTrue();

        doNothing().when(mockChecker).setEnabled(false);
        mockChecker.setEnabled(false);
        verify(mockChecker, times(1)).setEnabled(false);

        when(mockChecker.isEnabled()).thenReturn(false);
        assertThat(mockChecker.isEnabled()).isFalse();
    }

    @Test
    @DisplayName("测试超时时间设置")
    void testTimeoutSettings() {
        long timeout = 5000L;

        doNothing().when(mockChecker).setTimeoutMillis(timeout);
        mockChecker.setTimeoutMillis(timeout);

        when(mockChecker.getTimeoutMillis()).thenReturn(timeout);
        assertThat(mockChecker.getTimeoutMillis()).isEqualTo(timeout);
    }

    @Test
    @DisplayName("测试健康检查方法签名")
    void testHealthCheckMethodSignatures() {
        // 验证接口方法存在
        PluginHealthReport report = PluginHealthReport.createHealthy("test", java.util.Collections.emptyList());
        
        // 验证快速检查
        PluginHealthStatus status = PluginHealthStatus.HEALTHY;
        when(mockChecker.quickHealthCheck(mockPlugin)).thenReturn(status);
        assertThat(mockChecker.quickHealthCheck(mockPlugin)).isEqualTo(status);
        
        // 验证完整检查
        PluginHealthReport mockReport = PluginHealthReport.createHealthy("test", java.util.Collections.emptyList());
        when(mockChecker.checkHealth(mockPlugin)).thenReturn(mockReport);
        assertThat(mockChecker.checkHealth(mockPlugin)).isEqualTo(mockReport);
    }

    @Test
    @DisplayName("测试检查器状态变化")
    void testCheckerStateChanges() {
        // 初始状态为启用
        when(mockChecker.isEnabled()).thenReturn(true);
        assertThat(mockChecker.isEnabled()).isTrue();

        // 禁用检查器
        doNothing().when(mockChecker).setEnabled(false);
        mockChecker.setEnabled(false);
        verify(mockChecker).setEnabled(false);

        // 验证状态变更
        when(mockChecker.isEnabled()).thenReturn(false);
        assertThat(mockChecker.isEnabled()).isFalse();

        // 重新启用
        doNothing().when(mockChecker).setEnabled(true);
        mockChecker.setEnabled(true);
        verify(mockChecker).setEnabled(true);

        when(mockChecker.isEnabled()).thenReturn(true);
        assertThat(mockChecker.isEnabled()).isTrue();
    }

    @Test
    @DisplayName("测试默认超时时间")
    void testDefaultTimeout() {
        long defaultTimeout = 0L; // 默认值
        when(mockChecker.getTimeoutMillis()).thenReturn(defaultTimeout);
        assertThat(mockChecker.getTimeoutMillis()).isEqualTo(defaultTimeout);
    }

    @Test
    @DisplayName("测试超时时间设置和获取")
    void testTimeoutSettingAndGetting() {
        // 测试多种超时时间
        long[] timeouts = {1000L, 5000L, 10000L, 30000L};

        for (long timeout : timeouts) {
            doNothing().when(mockChecker).setTimeoutMillis(timeout);
            when(mockChecker.getTimeoutMillis()).thenReturn(timeout);

            mockChecker.setTimeoutMillis(timeout);
            assertThat(mockChecker.getTimeoutMillis()).isEqualTo(timeout);
        }
    }

    @Test
    @DisplayName("测试检查器的不可变性")
    void testCheckerImmutability() {
        // 验证检查器的状态是独立变化的
        when(mockChecker.isEnabled()).thenReturn(true);
        when(mockChecker.getTimeoutMillis()).thenReturn(5000L);
        when(mockChecker.getName()).thenReturn("test-checker");

        assertThat(mockChecker.isEnabled()).isTrue();
        assertThat(mockChecker.getTimeoutMillis()).isEqualTo(5000L);
        assertThat(mockChecker.getName()).isEqualTo("test-checker");

        // 验证状态变化不会影响其他状态
        doNothing().when(mockChecker).setEnabled(false);
        mockChecker.setEnabled(false);

        // 其他状态应该保持不变
        assertThat(mockChecker.getTimeoutMillis()).isEqualTo(5000L);
        assertThat(mockChecker.getName()).isEqualTo("test-checker");
    }

    @Test
    @DisplayName("测试空参数处理")
    void testNullParameterHandling() {
        // 验证对null插件的处理
        Plugin nullPlugin = null;
        PluginHealthStatus status = PluginHealthStatus.UNKNOWN;

        when(mockChecker.quickHealthCheck(nullPlugin)).thenReturn(status);
        assertThat(mockChecker.quickHealthCheck(nullPlugin)).isEqualTo(status);

        PluginHealthReport report = PluginHealthReport.createUnknown("test", "未知状态", new IllegalArgumentException("插件为空"));
        when(mockChecker.checkHealth(nullPlugin)).thenReturn(report);
        assertThat(mockChecker.checkHealth(nullPlugin)).isEqualTo(report);
    }

    @Test
    @DisplayName("测试描述信息变化")
    void testDescriptionChanges() {
        String description1 = "Original description";
        String description2 = "Updated description";

        when(mockChecker.getDescription()).thenReturn(description1);
        assertThat(mockChecker.getDescription()).isEqualTo(description1);

        // 模拟描述变化（如果支持）
        when(mockChecker.getDescription()).thenReturn(description2);
        assertThat(mockChecker.getDescription()).isEqualTo(description2);
    }
}