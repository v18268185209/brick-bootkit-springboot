package com.zqzqq.bootkits.core.dependency;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * 插件依赖解析结果测试
 */
@DisplayName("PluginDependencyResolution Test")
class PluginDependencyResolutionTest {

    @Test
    @DisplayName("测试创建成功的解析结果")
    void testCreateSuccessfulResolution() {
        List<String> resolvedDependencies = Arrays.asList("plugin-a", "plugin-b", "plugin-c");
        List<String> warnings = Arrays.asList("Warning message");

        PluginDependencyResolution resolution = PluginDependencyResolution.success(resolvedDependencies, warnings);

        assertThat(resolution.isSuccess()).isTrue();
        assertThat(resolution.getResolvedDependencies()).isEqualTo(resolvedDependencies);
        assertThat(resolution.getErrors()).isEmpty();
        assertThat(resolution.getWarnings()).isEqualTo(warnings);
    }

    @Test
    @DisplayName("测试创建失败的解析结果")
    void testCreateFailureResolution() {
        List<String> errors = Arrays.asList("Error 1", "Error 2");
        List<String> warnings = Arrays.asList("Warning message");

        PluginDependencyResolution resolution = PluginDependencyResolution.failure(errors, warnings);

        assertThat(resolution.isSuccess()).isFalse();
        assertThat(resolution.getResolvedDependencies()).isEmpty();
        assertThat(resolution.getErrors()).isEqualTo(errors);
        assertThat(resolution.getWarnings()).isEqualTo(warnings);
    }

    @Test
    @DisplayName("测试创建默认成功解析结果")
    void testCreateDefaultSuccessResolution() {
        PluginDependencyResolution resolution = PluginDependencyResolution.success();

        assertThat(resolution.isSuccess()).isTrue();
        assertThat(resolution.getResolvedDependencies()).isEmpty();
        assertThat(resolution.getErrors()).isEmpty();
        assertThat(resolution.getWarnings()).isEmpty();
    }

    @Test
    @DisplayName("测试创建默认失败解析结果")
    void testCreateDefaultFailureResolution() {
        PluginDependencyResolution resolution = PluginDependencyResolution.failure();

        assertThat(resolution.isSuccess()).isFalse();
        assertThat(resolution.getResolvedDependencies()).isEmpty();
        assertThat(resolution.getErrors()).isEmpty();
        assertThat(resolution.getWarnings()).isEmpty();
    }

    @Test
    @DisplayName("测试静态工厂方法")
    void testStaticFactoryMethods() {
        // 测试 success 方法
        PluginDependencyResolution success1 = PluginDependencyResolution.success();
        assertThat(success1.isSuccess()).isTrue();

        PluginDependencyResolution success2 = PluginDependencyResolution.success(Arrays.asList("dep1"));
        assertThat(success2.isSuccess()).isTrue();
        assertThat(success2.getResolvedDependencies()).containsExactly("dep1");

        // 测试 failure 方法
        PluginDependencyResolution failure1 = PluginDependencyResolution.failure();
        assertThat(failure1.isSuccess()).isFalse();

        PluginDependencyResolution failure2 = PluginDependencyResolution.failure(Arrays.asList("error"));
        assertThat(failure2.isSuccess()).isFalse();
        assertThat(failure2.getErrors()).containsExactly("error");
    }

    @Test
    @DisplayName("测试不可变集合")
    void testUnmodifiableCollections() {
        List<String> dependencies = new ArrayList<>();
        dependencies.add("dep1");
        dependencies.add("dep2");

        List<String> warnings = new ArrayList<>();
        warnings.add("warning1");

        PluginDependencyResolution resolution = PluginDependencyResolution.success(dependencies, warnings);

        // 尝试修改返回的集合应该失败
        assertThatThrownBy(() -> resolution.getResolvedDependencies().add("new-dep"))
            .isInstanceOf(UnsupportedOperationException.class);

        assertThatThrownBy(() -> resolution.getErrors().add("new-error"))
            .isInstanceOf(UnsupportedOperationException.class);

        assertThatThrownBy(() -> resolution.getWarnings().add("new-warning"))
            .isInstanceOf(UnsupportedOperationException.class);
    }

    @Test
    @DisplayName("测试空参数处理")
    void testNullParameterHandling() {
        // 测试null依赖列表
        PluginDependencyResolution resolution1 = PluginDependencyResolution.success(null);
        assertThat(resolution1.getResolvedDependencies()).isEmpty();

        // 测试null错误列表
        PluginDependencyResolution resolution2 = PluginDependencyResolution.failure(null);
        assertThat(resolution2.getErrors()).isEmpty();

        // 测试null警告列表
        PluginDependencyResolution resolution3 = PluginDependencyResolution.success(Arrays.asList("dep"), null);
        assertThat(resolution3.getWarnings()).isEmpty();
    }

    @Test
    @DisplayName("测试复杂解析结果")
    void testComplexResolutionResult() {
        List<String> resolved = Arrays.asList(
            "core-plugin",
            "database-plugin", 
            "logging-plugin",
            "security-plugin"
        );

        List<String> warnings = Arrays.asList(
            "Database plugin version is deprecated",
            "Consider upgrading to the latest logging plugin"
        );

        List<String> errors = Arrays.asList(
            "Security plugin version conflict detected"
        );

        PluginDependencyResolution resolution = PluginDependencyResolution.success(resolved, warnings);

        // 验证所有字段
        assertThat(resolution.isSuccess()).isTrue();
        assertThat(resolution.getResolvedDependencies()).hasSize(4);
        assertThat(resolution.getResolvedDependencies()).containsExactlyElementsOf(resolved);
        assertThat(resolution.getWarnings()).hasSize(2);
        assertThat(resolution.getErrors()).isEmpty();
    }

    @Test
    @DisplayName("测试带有部分错误的解析结果")
    void testResolutionWithPartialErrors() {
        List<String> resolved = Arrays.asList("plugin-a", "plugin-b");
        List<String> warnings = Arrays.asList("Plugin-c version mismatch");
        List<String> errors = Arrays.asList("Plugin-d not found");

        PluginDependencyResolution resolution = PluginDependencyResolution.failure(errors, warnings);
        
        // 即使有部分解析成功的依赖，整体结果仍然是失败
        assertThat(resolution.isSuccess()).isFalse();
        assertThat(resolution.getResolvedDependencies()).isEmpty(); // 失败时解析依赖列表为空
        assertThat(resolution.getErrors()).isEqualTo(errors);
        assertThat(resolution.getWarnings()).isEqualTo(warnings);
    }

    @Test
    @DisplayName("测试大规模依赖解析")
    void testLargeScaleDependencyResolution() {
        List<String> largeDependencyList = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            largeDependencyList.add("plugin-" + i);
        }

        PluginDependencyResolution resolution = PluginDependencyResolution.success(largeDependencyList);

        assertThat(resolution.isSuccess()).isTrue();
        assertThat(resolution.getResolvedDependencies()).hasSize(1000);
        assertThat(resolution.getResolvedDependencies().get(0)).isEqualTo("plugin-0");
        assertThat(resolution.getResolvedDependencies().get(999)).isEqualTo("plugin-999");
    }

    @Test
    @DisplayName("测试依赖解析结果的复制")
    void testResolutionResultCopying() {
        List<String> originalDeps = Arrays.asList("dep1", "dep2");
        List<String> originalWarnings = Arrays.asList("warning1");
        
        PluginDependencyResolution original = PluginDependencyResolution.success(originalDeps, originalWarnings);
        
        // 创建副本
        List<String> copiedDeps = new ArrayList<>(original.getResolvedDependencies());
        List<String> copiedWarnings = new ArrayList<>(original.getWarnings());
        
        // 修改副本不影响原始对象
        copiedDeps.add("dep3");
        copiedWarnings.add("warning2");
        
        assertThat(original.getResolvedDependencies()).hasSize(2);
        assertThat(original.getWarnings()).hasSize(1);
        assertThat(copiedDeps).hasSize(3);
        assertThat(copiedWarnings).hasSize(2);
    }

    @Test
    @DisplayName("测试解析结果的迭代")
    void testResolutionResultIteration() {
        List<String> dependencies = Arrays.asList("plugin-a", "plugin-b", "plugin-c");
        PluginDependencyResolution resolution = PluginDependencyResolution.success(dependencies);

        // 测试迭代依赖列表
        int count = 0;
        for (String dep : resolution.getResolvedDependencies()) {
            assertThat(dep).isNotNull();
            count++;
        }
        assertThat(count).isEqualTo(3);

        // 测试迭代错误列表（应该为空）
        count = 0;
        for (String error : resolution.getErrors()) {
            count++;
        }
        assertThat(count).isEqualTo(0);

        // 测试迭代警告列表
        List<String> warnings = Arrays.asList("warning1", "warning2");
        PluginDependencyResolution resolutionWithWarnings = PluginDependencyResolution.success(dependencies, warnings);
        
        count = 0;
        for (String warning : resolutionWithWarnings.getWarnings()) {
            assertThat(warning).isNotNull();
            count++;
        }
        assertThat(count).isEqualTo(2);
    }

    @Test
    @DisplayName("测试解析结果的序列化安全性")
    void testResolutionResultSerializationSafety() {
        List<String> dependencies = Arrays.asList("dep1", "dep2");
        PluginDependencyResolution resolution = PluginDependencyResolution.success(dependencies);

        // 测试对象在序列化/反序列化时保持状态
        try {
            // 模拟序列化过程
            String serialized = resolution.toString();
            assertThat(serialized).isNotNull();
            
            // 验证反序列化后状态一致
            assertThat(resolution.getResolvedDependencies()).isEqualTo(dependencies);
            assertThat(resolution.isSuccess()).isTrue();
            
        } catch (Exception e) {
            // 如果序列化失败，这是正常的，因为我们主要测试逻辑状态
        }
    }

    @Test
    @DisplayName("测试解析结果的内存效率")
    void testResolutionResultMemoryEfficiency() {
        // 测试大量依赖时的内存使用
        List<String> largeList = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            largeList.add("plugin-" + i);
        }

        PluginDependencyResolution resolution = PluginDependencyResolution.success(largeList);
        
        // 验证引用而不是副本（如果实现正确）
        assertThat(resolution.getResolvedDependencies()).isEqualTo(largeList);
        
        // 验证集合是不可变的
        assertThatThrownBy(() -> resolution.getResolvedDependencies().clear())
            .isInstanceOf(UnsupportedOperationException.class);
    }

    @Test
    @DisplayName("测试解析结果状态一致性")
    void testResolutionResultStateConsistency() {
        PluginDependencyResolution successResolution = PluginDependencyResolution.success();
        PluginDependencyResolution failureResolution = PluginDependencyResolution.failure();

        // 验证成功状态的一致性
        assertThat(successResolution.isSuccess()).isTrue();
        assertThat(successResolution.hasErrors()).isFalse();
        assertThat(successResolution.hasWarnings()).isFalse();
        assertThat(successResolution.getResolvedDependencies().isEmpty()).isTrue();

        // 验证失败状态的一致性
        assertThat(failureResolution.isSuccess()).isFalse();
        assertThat(failureResolution.hasErrors()).isFalse(); // 空错误列表
        assertThat(failureResolution.hasWarnings()).isFalse(); // 空警告列表
        assertThat(failureResolution.getResolvedDependencies().isEmpty()).isTrue();
    }
}